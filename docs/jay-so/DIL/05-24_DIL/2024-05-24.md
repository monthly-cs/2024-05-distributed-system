# 📖 2024-05-24 DIL

---

## 😀 3장. 시간 동기화 문제와 논리적 시계(Time synchronization problems and logical clocks)

### 1️⃣ 이중화된 데이터베이스 문제

#### 분산된 데이터베이스의 병행 갱신
- 이번에는 앞서 2장에서의 계좌이체 사례에서 봤었던 은행의 정보 관리의 사례를 살펴봅시다.

![1.png](/docs/jay-so/DIL/05-24_DIL/image/1.png)

- Alice는 K은행에 계좌를 가지고 있으며, K은행은 장애로 인해 계좌정보의 접근이 불가능하거나, 계좌정보가 사라지는 방지하기 위해, 다음과 같이 서울과 부산에 데이터베이스를 이중화했습니다.
- 이에 서울과 부산에서 운영중인 DB에는 동일한 계좌의 정보가 있으며, 만약 서울에 있는 DB에서 정전으로 인해 중단되는 상황 및 위급 상황에서 부산의 K은행의 DB를 이용하여 은행 업무를 이어나가기 위해 대비하였습니다.

**Q. 과연 다음과 같이 데이터베이스를 운영한다면, 안정성과 라이브니스를 위반하지 않고 정상적으로 은행 업무를 할 수 있을까?**

![2.png](/docs/jay-so/DIL/05-24_DIL/image/2.png)

예시
- 서울과 부산에 있는 DB는 정상적으로 작동되고 있습니다.
- Alice의 계좌에는 만원이 존재합니다.

서울의 K은행
- Alice는 더 가까이에 있는 서울의 K은행에 방문하여, 천원을 입금했습니다.

부산의 K은행
- 부산의 K은행은 이자 결정 지급을 담당하며, 입금과 거의 동시에 1%의 이자가 지급되어 부산의 DB에 반영되었습니다.

![3.png](/docs/jay-so/DIL/05-24_DIL/image/3.png)

![4.png](/docs/jay-so/DIL/05-24_DIL/image/4.png)

- 서울과 부산에 있는 Alice의 K은행의 데이터는 동일해야 함으로, 서울의 K은행은 부산에 있는 데이터베이스에 천원이 입금된 것을 알리고, 반대로 부산은 서울에게 1%의 이자를 지급하라고 서로 메시지를 전달합니다.

서울의 K은행 -> 부산의 K은행
- Alice의 계좌에 천원이 입금되었다는 것을 알립니다.

부산의 K은행 -> 서울의 K은행
- Alice의 계좌에서 1%의 이자를 지급하라는 것을 알립니다.

![5.png](/docs/jay-so/DIL/05-24_DIL/image/5.png)

![6.png](/docs/jay-so/DIL/05-24_DIL/image/6.png)

##### ⚠️ 문제점

서울의 K은행
- 입금으로 인해 계좌에 남아 있는 정보가 만천원이 되었으며, 이에 대한 1%의 이자 계산시 총 11,110원으로 계좌정보가 업데이트되었습니다.

부산의 K은행
- 먼저 만원에 대한 이자를 지급한 10,100원의 상황에서, 입금 알림을 받아 11,100원으로 계좌정보가 업데이트 되었습니다.

-> 서울과 부산의 K은행의 데이터베이스에서 비일관적인 결과가 나오게 되며, 차이가 발생하게 됩니다.

![7.png](/docs/jay-so/DIL/05-24_DIL/image/7.png)

**Q. 데이터베이스의 입금과 이자 지급 중에서 먼저 일어난 순서대로 수행하면 되지 않을까?**
- 이는 서울과 부산 지점의 데이터베이스의 설정 시간이 오차가 없이 정확히 없어야한다는 전제 조건을 만족해야 가능합니다.

![8.png](/docs/jay-so/DIL/05-24_DIL/image/8.png)

<br/>

### 2️⃣ 시간 동기화 기법

**Q.위성을 이용하여 서로 다른 지역에 있는 DB의 시간을 맞추면 되지 않을까?**
- 지하 등의 실내 공간에 있어 위성 신호를 받지 못할 수도 있으며, 위성 신호를 받더라도 분산된 환경에서 작은 시간의 오차가 발생할 수 있습니다.

**Q. 시간을 알려주는 서버가 있다고 가정하고, 해당 서버를 통해 시간을 가져오면 되지 않을까?**
- 클라이언트가 메시지를 보낼때 네트워크 환경 및 여러 hops를 거쳐 요청을 보내는 시간과 오는 시간이 있기 때문에, 서버로부터 메시지를 받은 시간이 클라이언트가 서버로 시각을 물어보는때의 시각이라고 할 수 없습니다. 

![9.png](/docs/jay-so/DIL/05-24_DIL/image/9.png)


#### 크리스티안 알고리즘
**전제조건**
- 기존의 시간을 알려주는 서버가 있다고 가정하에, 다음과 같이 네트워크에서 메시지가 이동하는 시간을 고려하여 알려주는 **"크리스티안 알고리즘"이 존재**합니다.
- 또한 **클라이언트는 서버가 회신한 메시지에 기록한 T2,T3은 정확하다**고 가정합니다.

![10.png](/docs/jay-so/DIL/05-24_DIL/image/10.png)

**작동 과정**

1. 클라이언트는 시간을 알려주는 서버의 문의 시, 자신의 시계가 가리키고 있는 시각 T1의 정보를 첨부하여 전송합니다.
2. 서버는 클라언트로 부터 메시지를 받을 때, 서버를 기준으로 T2라는 시간에 받았으며 이를 기록합니다.
3. 서버는 클라이언트 컴퓨터에게 회신하는 시점 T3를 기록하고, T2와 함께 해당 정보를 클라이언트에게 보냅니다.
4. 클라이언트는 서버가 보낸 회신 메시지를 받은 시점에 T4라고 기록합니다.


- 그림을 통해 다음과 같이 T4는 T3에서부터 해당 메시지가 클라이언트에게 도착하는데까지 걸리는 시간인 δresp를 더하여 알 수 있습니다.

``` text
T4 = T3 + δresp
```

![11.png](/docs/jay-so/DIL/05-24_DIL/image/11.png)


##### ⚠️ 문제점
- **δresp값은 실제로 알 수가 없습니다.**
- **클라이언트는 서버로부터 메시지를 수신한 T4의 시간은 알지만, 서버가 기록한 T3의 시간을 클라이언트가 모르기 때문입니다.**






