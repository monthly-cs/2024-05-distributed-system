# 2. 중계자와 2단계 커밋 프로토콜

- 중계자가 있는 상태에서 분산된 프로세스들 간의 거래를 안전하게 이해하고 종결시킬 수 있는 방안은?

## 2.1. 계좌 이체 문제

### 분산 프로세스 간 올바른 거래의 어려움

- Alice가 Bob에게 은행 계좌로 일정 금액을 이체 할 때
    - Alice K은행 계좌 10,000원, Bob K은행 계좌 10,000원. K은행과 S은행은 네트워크에 연결되어 있음
    - Alice가 Bob에게 1,000원을 이체하면 정상인 경우 Alice 계좌 잔고는 9,000원, Bob 계좌 잔고는 11,000원이 되어야 함
    - Alice가 1,000원을 Bob의 은행으로 이체하고 잔고를 9,000원으로 갱신하면 될까? → 두 장군 문제
        - Alice가 안전하게 잔고를 갱신하기 위해서는 Bob 은행으로부터 이체 받았다는 메시지 수신이 필요하나
        - 비동기적 통신으로 인해 Bob 은행에서 이체 메시지를 받을 보장이 없음
        - Bob 은행 계좌 갱신 없이 Alice 은행 계좌만 갱신하면 Alice 손해 발생
    - Bob이 Alice로부터 이체를 알리는 메시지를 받은 경우
        - Bob은 Alice에게 알려야 할 내용을 메시지를 통해 보내야 함
        - Bob의 메시지가 Alice에게 전달되지 않으면 Alice가 잔고를 갱신하지 않음
        - 따라서 Bob이 잔고를 갱신하면 않됨

## 2.2. 안전성과 라이브니스

- 분산 시스템에게 요구하는 두가지 요건
    - 안정성(Safety)
        - 잘못된 결과가 일어나서는 안 되는 원칙
        - 예: Alice만 잔고가 줄어드는 결과 or Bob만 잔고가 늘어나는 결과
    - 라이브니스(Liveness)
        - 원하는 결과가 반드시 어느 시점에서는 실현되어야 하는 원칙
        - 예: Alice의 잔고가 올바르게 줄어드는 것과 함께, Bob의 잔도고 올바르게 늘어나는 결과가 언제가는 발생함

### 안정성과 라이브니스 동시 충족 문제

- 안정성에만 촛점을 맞추는 경우
    - 두 장군 문제와 같이 서로 메시지를 반복적으로 주고 받다가 결국 이체를 완료하지 못함
    - 라이브니스 요구사항도 충족하지 못함
- 양자 합의 방식을 통해 안정성과 라이브니스를 모두 충족하면서 원하는 이체를 수행하는 것은 매우 어려움

### 확약과 합의의 어려움

- 두 장군의 문제에서 각 장군은 결정을 독립적으로 내릴 수 없으며 두 장군 사이에서 메시지를 주고 받는 방식으로는 쉽게 ‘합의’에 이르지 못함

## 2.3. 2단계 커밋 프로토콜

- 트랜잭션(Transaction) : 분산 컴퓨팅 참여 프로세스들 간의 거래 행위
    - 트랜잭션이 안전하게 수행되려면 ‘원자성’(all or nothing)을 가져야 함
    - Alice가 잔고 갱신을 확약하지 않으면, Bob도 잔고 갱신을 확약하지 않음
    - Alice가 잔고 갱신을 확약하면, Bob도 잔고 갱신을 확약해야 함
- 2단계 커밋 프로토콜 : Alice와 Bob의 원자성을 보장하면서 트랜잭션 수행을 보장할 수 있는 방안
    - 트랜잭션을 중계하는 트랜잭션 코디네이터 필요

### 스트로우맨 프로토콜

- 작동 흐름
    - Alice가 1,000원을 Bob S은행 계좌에 이체할 것을 TC에 요청
    - TC는 Alice K은행 계좌에서 1,000원 출금, Bob S은행 계좌에 1,000원 입금을 동시에 전달
    - TC는 Alice에게 요청 전달 완료 회신
    - K은행과 S은행 간 직접 메시지 교환 통신 없고, TC가 두 은행에 동시에 전달했지만, 두 은행간의 계좌 갱신 여부를 동시에 결정할 수 없음
- 스트로우맨 프로토콜이 작동하지 않는 경우
    - 경우 1 : K은행 Alice의 계좌에 1000원이 원는 경우
        - S은행 Bob의 계좌에 1000원을 입금하면 안 되지만, 출금과 입금의 요청이 동시에 진행되어 막을 수 없음
    - 경우 2 : S은행 Bob의 계좌가 존재하지 않은 경우
        - Alice는 1000원을 잃음
    - 경우 3 : Alice K은행이 TC로부터 요청을 받기 전에 시스템이 중단된 경우
    - 경우 4 : TC와 Bob의 은행 사이의 네트워크가 중단된 경우
    - 경우 5 : TC가 중단된 경우
- 스트로우맨 프로코콜은 안전하지 않음
    - 장애  인지 및 피해 복구가 어려움
    - 안전성 위반을 방지하는 장애 내성을 가진 분산 컴퓨팅 시스템을 구축할 필요가 있음

### 원자적 커밋 프로토콜

- 작동 흐름
    - Alice가 TC에게 K은행에서 S계좌로 이체할 명령(Go)을 내림
    - TC가 Alice의 명령을 받으면, 두 은행에게 준비하라는 명령(Prepare)을 동시에 내림
    - 각 은행은 준비 명령에 대해서 예 또는 아니요로 TC에게 회신함
    - TC는 두 은행으로 받은 회신을 바탕으로 이행을 확약(Commit)할지 아니면 명령을 취소(Abort)할지 결정해야 함
    - 만약 두 은행에서 모두 ‘예”라고 회신하면 TC는 두 은행에 이행하라는 메시지를 보냄
        - 한 은행이라도 ‘아니오’라고 회신하면 TC는 명령을 취소한다는 메시지를 보냄
    - 만약 TC가 이행 확약 명령 메시지를 보내면 최종적으로 Alice에게 정상 메시지를 보냄
        - 명령 취소 메시지를 보내면 Alice에게 실패 메시지를 보냄

### 안정성 보장을 위한 조치

- TC가 확약 메시지를 보낸 후 TC 중단 시
    - Alice에게 이체 처리 여부를 회신 할 수 없음
    - TC가 복구 되었을 때 TC가 확약 메시지를 보냈는지 여부를 기억하지 못하면 사용자에게 이체처리 결과를 알려줄 수 없음
    - TC의 확약 메시지가 정상적으로 K은행, S은행에 도달하여 입출금이 진행되었는데 TC는 요청 처리 상태를 모르게 됨
    - 해결방안 : TC는 확약 메시지를 보내기 직전에 로그를 남김
        - TC 복구 시 로그를 통해 Commit 전송을 기억함
- K은행, S은행이 준비 메시지에 정상 응답 한 후 중단 시
    - 은행은 TC가 보내는 확약 메시지를 전달 받지 못함
    - 은행 복구 시 은행은 준비 메시지 응답 기억이 없고 중단된 상황에서 TC가 보낸 확약 메시지도 받지 못했음
    - 실제로 은행은 TC에게 준비 메시지를 응답 했지만, 준비되지 않은 것으로 인식하여 출금 명령을 이행하지 않음 (안전성 조건 위반)
    - 상대 은행이 정상 운영 중인 경우에 상대 은행은 계좌 갱신이 이루어져 원자성이 보장되지 않음
    - 해결방안 : 은행도 준비 메시지 회신 전 로그를 남김
        - 로그에서 준비 메시지 “정상”인데 확약 메시지를 못 받은 경우 TC에게 준비 메시지를 재전송하여 확약 메시지를 전달받아 출금 작업 이행 준비 필요
- 명령 또는 회신 메시지 로그를 남기려는 찰나에 중단 시
    - TC 복구 시 확약 메시지 로그가 없는 경우 이체를 취소함
    - 은행 복구 시 준비 정상 응답 메시지 로그가 없는 경우 이체를 취소함
- 프로토콜에 참여하는 모든 주체가 동의해야 이체 명령이 실행됨 (안전성/원자성 충족)

### 라이브니스 보장을 위한 조치

- 이체 처리 진행 중 네트워크 문제 또는 TC, 은행 중단 시 시간이 지체되어 전체 과정을 다시 진행하거나 은행이 대기하는 문제가 발생하는 경우
    - 라이브니스 보장이 어려움
    - 해결방안 : 은행 간 서로의 상태를 확인하는 과정 추가
        - 경우 1 : S은행 무응답
            - K은행은 TC로부터 후속 명령을 기다림
        - 경우 2 : S은행이 TC로부터 확약 또는 취소 명령 수신을 응답
            - K은행도 동일한 명령을 받은 것으로 간주 (TC와 K은행 간 네트워크 문제로 판단 가능)
        - 경우 3 : S은행이 K은행에게 TC에게 응답하지 않았거나 준비 실패 메시지 회신했다고 응답
            - K은행은 취소 처리
        - 경우 4 : S은행이 K은행에게 준비 성공 메시지 회산했다고 응답
            - K와 S은행은 TC로 부터 후속 명령을 기다림

<aside>
💡 2단계 커밋 프로토콜 = 원자적 커밋 프로토콜 + (선제적 메시지 기록, 메시지 재전송, 프로토콜 종료 및 재시작)

</aside>

### 2단계 커밋 프로토콜 수행 예시

- 2단계 커밋 프로토콜 : 원자적 커밋 프로토콜에 선제적 메시지 기록을 통한 메시지 재전송과 프로토콜 종료 또는 재시작 조건을 더해서 이행 확약의 안전성과 라이브니스를 보장하는 프로토콜
    1. 클라이언트가 TC에게 트랜잭션 명령 메시지를 보냄
    2. TC가 트랜잭션에 참여하는 모든 프로세스들에게 트랜잭션을 수행할 준비를 하라는 메시지를 보냄
    3. 준비하라는 메시지를 받은 각 프로세스는 TC에게 “예” 또는 “아니오”로 답변
    4. TC의 결정
        1. 모든 프로세스들이 “예”라고 한다면, TC는 모든 프로세스에게 명령을 이행 확약 메시지를 보냄
        2. 어느 한 프로세스라도 “아니오”라고 답하면 클라이언트의 이행을 취소한다는 메시지를 보
- 시나리오
    - S은행이 준비 정상 응답하지 않았고, 로그도 남지 않은 상태에서 중단 시 (p. 37 그림 2-6, 2-7)
        - S은행 복구 시 준비 정상 응답한 적이 없음
        - TC는 제시간에 S은행으로 부터 응답을 받지 못했으므로 취소 메시지를 보낸 상황임
        - S은행 복구 시 준비 정상 응답한 로그가 없으면 준비상황 취소처리함
    - S은행이 준비 정상 응답한 후 중단 시 (p. 37 그림 2-8, 2-9)
        - S은행 복구 시 준비 정상 응답 로그가 있기 때문에 TC가 결정을 내렸으리라 예측가능함
        - TC가 확약 또는 취소 메시지를 보내는대로 처리
        - TC 메시지 미수신 시 K은행에 문의
    - S은행이 준비 정상 응답 후 네트워크 장애로 TC에게 전달되지 않은 경우  (p. 37 그림 2-10)
        - TC는 응답을 기다리다가 취소 메시지 전송
        - 이후 S은행 복구 시 준비 정상 응답 로그가 있음. TC가 어떤 결정을 했는지는 모름
        - TC에서 준비 정상 응답을 다시 보내어 TC의 결정을 물어 볼 수 있음
        - TC 문의 시 응답이 없을 경우 S은행에 문의

## 핵심요약

- ‘안정성(Safety)’이란 잘못된 결과가 일어나서는 안 되는 것임
- ‘라이브니스(Liveness)’란 원하는 결과가 결국에는 일어나야 한다는 것임
- 분산 컴퓨팅 장치들 간의 거래 행위를 ‘트랜잭션(Transaction)’이라고 하며, 트랜잭션이 ‘원자성(Atomicity)’을 가지고 있다는 것은 분산 컴퓨팅 장치들이 모두 트랜잭션 이행에 ‘확약(Commit)’ 하거나, 아예 모두 이행을 하지 않는 것을 말함. 원자성을 가진 트랜잭션에 부분적인 확약이란 있을 수 없음. 즉 누구는 확약하고 누구는 확약하지 않는 상태는 있을 수 없음
- 트랜잭션의 원자성을 위하여 ‘2단계 커밋 프로토콜(Two-Phase Commit Protocol)’을 사용할 수 있음
- 2단계 커밋 프로토콜은 안전성을 보장하며, TC와 트랜잭션에 참여하는 프로세스들이 장애가 일어나도 복구가 된다면 라이브니스를 충족할 수 있음
- TC 또는 트랜잭션 참여 프로세스들이 2단계 커밋 프로토콜 이행 도중 장애를 일으키는 경우에 대비하여, TC는 이행 확약 명령 메시지를, 참여 프로세스들은 준비가 되었다는 “예” 메시지를 송신하기에 앞서 해당 메시지를 각자의 디스크에 먼저 기록하는 데, 이 기록을 ‘Write-Ahead Log’라고 함. 장애가 복구된 후에 메시지를 재송신할 지, 아니면 그동안 했던 일들을 취소(Abort)해야 할지 여부를 결정함
